<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SB 1123 Lot Layout Planner</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script crossorigin src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fafafa; color: #333; height: 100vh; overflow: hidden; }

.title-bar { display: flex; align-items: center; justify-content: space-between; background: #1B2A4A; color: white; padding: 10px 20px; height: 48px; flex-shrink: 0; }
.title-bar h1 { font-size: 16px; font-weight: 600; letter-spacing: 0.3px; }
.title-bar .brand { font-size: 13px; color: #8DA4C8; font-weight: 500; }
.title-bar .address { font-size: 13px; color: #B8CCE8; font-weight: 400; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

.app-layout { display: flex; height: calc(100vh - 48px); }
.sidebar { width: 288px; min-width: 288px; background: white; border-right: 1px solid #e0e0e0; overflow-y: auto; flex-shrink: 0; }
.sidebar::-webkit-scrollbar { width: 6px; }
.sidebar::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
.main-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
.canvas-wrap { flex: 1; position: relative; overflow: hidden; background: #f5f5f5; }
.stats-bar { background: white; border-top: 1px solid #e0e0e0; padding: 10px 16px; flex-shrink: 0; }

.section { padding: 12px 16px; border-bottom: 1px solid #eee; }
.section-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.8px; color: #1B2A4A; margin-bottom: 10px; }
.field { margin-bottom: 8px; }
.field label { display: block; font-size: 11px; color: #666; margin-bottom: 3px; font-weight: 500; }
.field input, .field select { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: #fafafa; }
.field input:focus, .field select:focus { outline: none; border-color: #3B7DD8; background: white; }
.field-row { display: flex; gap: 8px; }
.field-row .field { flex: 1; }
.toggle-group { display: flex; gap: 0; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; }
.toggle-btn { flex: 1; padding: 5px 8px; font-size: 12px; border: none; background: #fafafa; cursor: pointer; text-align: center; transition: all 0.15s; }
.toggle-btn.active { background: #3B7DD8; color: white; font-weight: 600; }
.toggle-btn:not(.active):hover { background: #eee; }
.checkbox-field { display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
.checkbox-field input[type="checkbox"] { width: auto; }
.checkbox-field label { margin: 0; font-size: 12px; color: #333; }
.action-buttons { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; }
.btn { padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.15s; background: white; }
.btn:hover { background: #f0f0f0; }
.btn-primary { background: #3B7DD8; color: white; border-color: #3B7DD8; }
.btn-primary:hover { background: #2C6BC0; }
.btn-danger { color: #D32F2F; border-color: #D32F2F; }
.btn-danger:hover { background: #FFEBEE; }

.stats-grid { display: flex; flex-wrap: wrap; gap: 4px 16px; align-items: center; }
.stat { display: flex; align-items: baseline; gap: 4px; }
.stat-label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
.stat-value { font-size: 14px; font-weight: 700; color: #1B2A4A; }
.stat-value.warn { color: #D32F2F; }
.stat-value.ok { color: #2E7D32; }
.stat-sep { width: 1px; height: 24px; background: #e0e0e0; margin: 0 4px; }
.compliance-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: 700; }
.compliance-badge.pass { background: #E8F5E9; color: #2E7D32; }
.compliance-badge.fail { background: #FFEBEE; color: #D32F2F; }

.lot-svg { width: 100%; height: 100%; touch-action: none; }
.dim-label { font-family: -apple-system, BlinkMacSystemFont, sans-serif; pointer-events: none; user-select: none; }
.tooltip-box { pointer-events: none; }

.title-actions { display: flex; gap: 8px; align-items: center; }
.title-btn { padding: 4px 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; background: transparent; color: white; font-size: 12px; cursor: pointer; font-weight: 500; }
.title-btn:hover { background: rgba(255,255,255,0.1); }

@media (max-width: 900px) {
  .sidebar { width: 240px; min-width: 240px; }
}
@media (max-width: 700px) {
  .app-layout { flex-direction: column; }
  .sidebar { width: 100%; min-width: 0; max-height: 40vh; border-right: none; border-bottom: 1px solid #e0e0e0; }
}
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback, useMemo } = React;

/* ── Helpers ───────────────────────────────────────────── */
function readParams() {
  const p = new URLSearchParams(window.location.search);
  return {
    width: p.get('width') ? Number(p.get('width')) : 60,
    depth: p.get('depth') ? Number(p.get('depth')) : 150,
    zone: p.get('zone') || 'R1',
    street: p.get('street') || 'S',
    address: p.get('address') ? decodeURIComponent(p.get('address').replace(/\+/g,' ')) : '',
    asking: p.get('asking') ? Number(p.get('asking')) : null,
    lotSF: p.get('lotSF') ? Number(p.get('lotSF')) : null,
    remDepth: p.get('remDepth') ? Number(p.get('remDepth')) : 0,
    driveWidth: p.get('driveWidth') ? Number(p.get('driveWidth')) : 20,
    driveSide: p.get('driveSide') || 'L',
  };
}

const GARAGE_W = 12; // garage bay width (feet), fixed
const GARAGE_D = 42; // max garage depth (feet), bounded by unit

function garageForUnit(u) {
  const gw = Math.min(GARAGE_W, u.h); // bay width along unit frontage
  const gd = Math.min(GARAGE_D, u.w); // depth into unit
  return { gw, gd, sf: gw * gd };
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* ── Auto-layout engine ────────────────────────────────── */
function computeAutoLayout(cfg) {
  const { lotW, lotD, frontSB, sideSB, rearSB, driveW, driveX, unitW, unitD,
          hasRemainder, remDepth, doubleLoaded } = cfg;
  const devD = lotD - frontSB - rearSB - (hasRemainder ? remDepth : 0);
  if (devD <= 0) return { units: [], driveX };

  const units = [];
  let newDriveX = driveX;
  const startY = frontSB + (hasRemainder ? remDepth : 0);

  if (doubleLoaded) {
    newDriveX = Math.round((lotW - driveW) / 2);
    const leftW = newDriveX;
    const rightW = lotW - newDriveX - driveW;
    const perRow = Math.max(0, Math.floor(devD / unitW));
    let id = 1;
    for (let i = 0; i < perRow && id <= 10; i++)
      units.push({ id: id++, x: 0, y: startY + i * unitW, w: Math.min(unitD, leftW), h: unitW });
    for (let i = 0; i < perRow && id <= 10; i++)
      units.push({ id: id++, x: newDriveX + driveW, y: startY + i * unitW, w: Math.min(unitD, rightW), h: unitW });
  } else {
    const isLeft = driveX <= lotW / 2;
    newDriveX = isLeft ? sideSB : lotW - sideSB - driveW;
    const unitX = isLeft ? sideSB + driveW : sideSB;
    const availW = lotW - 2 * sideSB - driveW;
    if (availW < 12) return { units: [], driveX: newDriveX };
    const perRow = Math.max(0, Math.floor(devD / unitW));
    let id = 1;
    for (let i = 0; i < perRow && id <= 10; i++)
      units.push({ id: id++, x: unitX, y: startY + i * unitW, w: Math.min(unitD, availW), h: unitW });
  }
  return { units, driveX: newDriveX };
}

/* ── Constraint checks ─────────────────────────────────── */
function checkConstraints(units, cfg) {
  const { lotW, lotD, frontSB, sideSB, rearSB, hasRemainder, remDepth,
          driveX, driveW, stories, lotSFOverride } = cfg;
  const warnings = [];
  if (units.length > 10) warnings.push('Unit count exceeds 10 maximum');

  const devStartY = hasRemainder ? remDepth : 0;
  const devArea = lotW * (lotD - devStartY);
  if (units.length > 0) {
    const parcelSize = devArea / units.length;
    if (parcelSize < 1200) warnings.push(`Avg parcel ${Math.round(parcelSize)} SF < 1,200 SF minimum`);
  }
  const unitArea = units.reduce((s, u) => s + u.w * u.h, 0);
  const buildableSF = unitArea * stories;
  const far = devArea > 0 ? buildableSF / devArea : 0;
  let farLimit = 0.5;
  if (units.length >= 8) farLimit = 1.25;
  else if (units.length >= 3) farLimit = 1.0;
  if (far > farLimit) warnings.push(`FAR ${far.toFixed(2)} exceeds ${farLimit} limit for ${units.length} units`);

  // Setback violations
  const minY = frontSB + devStartY;
  const maxY = lotD - rearSB;
  units.forEach(u => {
    if (u.x < sideSB - 0.5) warnings.push(`Unit ${u.id}: side setback violation (left)`);
    if (u.x + u.w > lotW - sideSB + 0.5) warnings.push(`Unit ${u.id}: side setback violation (right)`);
    if (u.y < minY - 0.5) warnings.push(`Unit ${u.id}: front setback violation`);
    if (u.y + u.h > maxY + 0.5) warnings.push(`Unit ${u.id}: rear setback violation`);
  });

  // Driveway overlap
  const driveRect = { x: driveX, y: devStartY + frontSB, w: driveW, h: lotD - devStartY - frontSB - rearSB };
  units.forEach(u => {
    if (rectsOverlap(u, driveRect)) warnings.push(`Unit ${u.id}: overlaps driveway`);
  });

  // Unit-unit overlap
  for (let i = 0; i < units.length; i++)
    for (let j = i + 1; j < units.length; j++)
      if (rectsOverlap(units[i], units[j]))
        warnings.push(`Unit ${units[i].id} overlaps Unit ${units[j].id}`);

  // Avg habitable size (total SF minus garage)
  if (units.length > 0) {
    const totalGarage = units.reduce((s, u) => s + garageForUnit(u).sf, 0);
    const avgHab = (unitArea * stories - totalGarage) / units.length;
    if (avgHab > 1750) warnings.push(`Avg unit ${Math.round(avgHab)} SF > 1,750 SF habitable max`);
  }
  return warnings;
}

/* ── Main App ──────────────────────────────────────────── */
function App() {
  const params = useMemo(readParams, []);

  // Lot state
  const [lotW, setLotW] = useState(params.width);
  const [lotD, setLotD] = useState(params.depth);
  const [zone, setZone] = useState(params.zone);
  const [street, setStreet] = useState(params.street);
  const [address, setAddress] = useState(params.address);
  const [asking] = useState(params.asking);
  const [lotSFOverride] = useState(params.lotSF);
  const [hasRemainder, setHasRemainder] = useState(params.remDepth > 0);
  const [remDepth, setRemDepth] = useState(params.remDepth || 0);

  // Standards
  const [frontSB, setFrontSB] = useState(15);
  const [sideSB, setSideSB] = useState(4);
  const [rearSB, setRearSB] = useState(4);
  const [stories, setStories] = useState(3);

  // Driveway — absolute position + width
  const initDriveX = params.driveSide === 'R' ? params.width - 4 - params.driveWidth : 4;
  const [driveX, setDriveX] = useState(initDriveX);
  const [driveW, setDriveW] = useState(params.driveWidth);

  // Unit defaults (for new units only)
  const [defUnitW, setDefUnitW] = useState(20);
  const [defUnitD, setDefUnitD] = useState(40);

  // Layout
  const [doubleLoaded, setDoubleLoaded] = useState(false);
  const [units, setUnits] = useState([]);
  const [ppsf, setPpsf] = useState(700);

  // Interaction
  const [hoveredUnit, setHoveredUnit] = useState(null);
  const [hoveredDrive, setHoveredDrive] = useState(false);
  const [dragInfo, setDragInfo] = useState(null); // { type, unitId?, edge? } for UI
  const dragRef = useRef(null); // full drag data
  const svgRef = useRef(null);
  const canvasRef = useRef(null);

  const cfg = useMemo(() => ({
    lotW, lotD, street, frontSB, sideSB, rearSB, driveW, driveX,
    unitW: defUnitW, unitD: defUnitD, hasRemainder, remDepth, doubleLoaded, stories, lotSFOverride
  }), [lotW, lotD, street, frontSB, sideSB, rearSB, driveW, driveX,
       defUnitW, defUnitD, hasRemainder, remDepth, doubleLoaded, stories, lotSFOverride]);

  // Auto-layout on first load
  useEffect(() => {
    const result = computeAutoLayout(cfg);
    setUnits(result.units);
    setDriveX(result.driveX);
  }, []);

  const runAutoLayout = useCallback(() => {
    const result = computeAutoLayout(cfg);
    setUnits(result.units);
    setDriveX(result.driveX);
  }, [cfg]);

  const addUnit = useCallback(() => {
    if (units.length >= 10) return;
    const id = units.length > 0 ? Math.max(...units.map(u => u.id)) + 1 : 1;
    const startY = frontSB + (hasRemainder ? remDepth : 0);
    // Place next to driveway
    const unitX = driveX + driveW;
    setUnits(prev => [...prev, { id, x: unitX, y: startY, w: defUnitD, h: defUnitW }]);
  }, [units, frontSB, hasRemainder, remDepth, driveX, driveW, defUnitD, defUnitW]);

  const removeUnit = useCallback((id) => {
    setUnits(prev => prev.filter(u => u.id !== id));
  }, []);

  // Snap driveway to edges
  const snapDriveLeft = useCallback(() => setDriveX(0), []);
  const snapDriveRight = useCallback(() => setDriveX(Math.max(0, lotW - driveW)), [lotW, driveW]);

  /* ── Computed stats ──────────────────────────────────── */
  const warnings = useMemo(() => checkConstraints(units, cfg), [units, cfg]);
  const totalLotSF = lotSFOverride || lotW * lotD;
  const devStartY = hasRemainder ? remDepth : 0;
  const devLotSF = lotW * (lotD - devStartY);
  const unitArea = units.reduce((s, u) => s + u.w * u.h, 0);
  const coverage = devLotSF > 0 ? (unitArea / devLotSF * 100) : 0;
  const garageSF = units.reduce((s, u) => s + garageForUnit(u).sf, 0);
  const totalBuildSF = unitArea * stories; // all floors (for FAR)
  const habitableSF = totalBuildSF - garageSF;
  const far = devLotSF > 0 ? totalBuildSF / devLotSF : 0;
  const avgParcel = units.length > 0 ? devLotSF / units.length : 0;
  const revenue = units.reduce((sum, u) => {
    const hab = u.w * u.h * stories - garageForUnit(u).sf;
    return sum + hab * ppsf;
  }, 0);

  /* ── SVG coordinate system ──────────────────────────── */
  const PAD = 30;
  const vbW = lotW + PAD * 2;
  const vbH = lotD + PAD * 2;
  const ox = PAD, oy = PAD;

  // Driveway rect (derived)
  const driveY = devStartY + frontSB;
  const driveH = Math.max(0, lotD - devStartY - frontSB - rearSB);

  /* ── Drag system ─────────────────────────────────────── */
  const toSvgCoords = useCallback((clientX, clientY) => {
    const svg = svgRef.current;
    if (!svg) return { x: 0, y: 0 };
    const pt = svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const ctm = svg.getScreenCTM().inverse();
    const svgPt = pt.matrixTransform(ctm);
    return { x: svgPt.x - ox, y: svgPt.y - oy };
  }, [ox, oy]);

  // Pointer down: start drag
  const startUnitMove = useCallback((e, unitId) => {
    e.preventDefault(); e.stopPropagation();
    const pt = toSvgCoords(e.clientX, e.clientY);
    const unit = units.find(u => u.id === unitId);
    if (!unit) return;
    dragRef.current = {
      type: 'unit-move', unitId,
      offsetX: pt.x - unit.x, offsetY: pt.y - unit.y,
      w: unit.w, h: unit.h
    };
    setDragInfo({ type: 'unit-move', unitId });
    svgRef.current?.setPointerCapture(e.pointerId);
  }, [units, toSvgCoords]);

  const startUnitResize = useCallback((e, unitId, edge) => {
    e.preventDefault(); e.stopPropagation();
    const pt = toSvgCoords(e.clientX, e.clientY);
    const unit = units.find(u => u.id === unitId);
    if (!unit) return;
    dragRef.current = {
      type: 'unit-resize', unitId, edge,
      startRect: { x: unit.x, y: unit.y, w: unit.w, h: unit.h },
      startPt: { x: pt.x, y: pt.y }
    };
    setDragInfo({ type: 'unit-resize', unitId, edge });
    svgRef.current?.setPointerCapture(e.pointerId);
  }, [units, toSvgCoords]);

  const startDriveMove = useCallback((e) => {
    e.preventDefault(); e.stopPropagation();
    const pt = toSvgCoords(e.clientX, e.clientY);
    dragRef.current = {
      type: 'drive-move',
      offsetX: pt.x - driveX, w: driveW
    };
    setDragInfo({ type: 'drive-move' });
    svgRef.current?.setPointerCapture(e.pointerId);
  }, [toSvgCoords, driveX, driveW]);

  const startDriveResize = useCallback((e, edge) => {
    e.preventDefault(); e.stopPropagation();
    const pt = toSvgCoords(e.clientX, e.clientY);
    dragRef.current = {
      type: 'drive-resize', edge,
      startRect: { x: driveX, w: driveW },
      startPt: { x: pt.x }
    };
    setDragInfo({ type: 'drive-resize', edge });
    svgRef.current?.setPointerCapture(e.pointerId);
  }, [toSvgCoords, driveX, driveW]);

  // Pointer move: update positions
  const handlePointerMove = useCallback((e) => {
    const drag = dragRef.current;
    if (!drag) return;
    const pt = toSvgCoords(e.clientX, e.clientY);

    if (drag.type === 'unit-move') {
      let nx = Math.round(pt.x - drag.offsetX);
      let ny = Math.round(pt.y - drag.offsetY);
      nx = Math.max(0, Math.min(lotW - drag.w, nx));
      ny = Math.max(0, Math.min(lotD - drag.h, ny));
      setUnits(prev => prev.map(u => u.id === drag.unitId ? { ...u, x: nx, y: ny } : u));
    }
    else if (drag.type === 'unit-resize') {
      const dx = Math.round(pt.x - drag.startPt.x);
      const dy = Math.round(pt.y - drag.startPt.y);
      let { x, y, w, h } = { ...drag.startRect };

      if (drag.edge === 'right') w = drag.startRect.w + dx;
      else if (drag.edge === 'left') { x = drag.startRect.x + dx; w = drag.startRect.w - dx; }
      else if (drag.edge === 'bottom') h = drag.startRect.h + dy;
      else if (drag.edge === 'top') { y = drag.startRect.y + dy; h = drag.startRect.h - dy; }

      // Enforce minimums (12' each dimension)
      if (w < 12 || h < 12) return;
      // Clamp to lot
      if (x < 0) return;
      if (y < 0) return;
      if (x + w > lotW) return;
      if (y + h > lotD) return;

      const newRect = { x, y, w, h };
      const dr = { x: driveX, y: driveY, w: driveW, h: driveH };

      setUnits(prev => {
        // Check collisions with other units
        for (const other of prev) {
          if (other.id === drag.unitId) continue;
          if (rectsOverlap(newRect, other)) return prev;
        }
        // Check collision with driveway
        if (rectsOverlap(newRect, dr)) return prev;
        return prev.map(u => u.id === drag.unitId ? { ...u, ...newRect } : u);
      });
    }
    else if (drag.type === 'drive-move') {
      let nx = Math.round(pt.x - drag.offsetX);
      nx = Math.max(0, Math.min(lotW - drag.w, nx));
      setDriveX(nx);
    }
    else if (drag.type === 'drive-resize') {
      const dx = Math.round(pt.x - drag.startPt.x);
      let x = drag.startRect.x;
      let w = drag.startRect.w;

      if (drag.edge === 'right') { w = drag.startRect.w + dx; }
      else if (drag.edge === 'left') { x = drag.startRect.x + dx; w = drag.startRect.w - dx; }

      if (w < 12 || x < 0 || x + w > lotW) return;
      setDriveX(x);
      setDriveW(w);
    }
  }, [toSvgCoords, lotW, lotD, driveX, driveY, driveW, driveH]);

  // Pointer up: end drag
  const handlePointerUp = useCallback((e) => {
    if (!dragRef.current) return;
    if (e && svgRef.current) {
      try { svgRef.current.releasePointerCapture(e.pointerId); } catch(ex) {}
    }
    dragRef.current = null;
    setDragInfo(null);
  }, []);

  /* ── Copy link ──────────────────────────────────────── */
  const copyLink = useCallback(() => {
    const p = new URLSearchParams();
    p.set('width', lotW); p.set('depth', lotD);
    p.set('zone', zone); p.set('street', street);
    if (address) p.set('address', address);
    if (asking) p.set('asking', asking);
    if (lotSFOverride) p.set('lotSF', lotSFOverride);
    if (hasRemainder && remDepth) p.set('remDepth', remDepth);
    p.set('driveWidth', driveW);
    p.set('driveSide', driveX < lotW / 2 ? 'L' : 'R');
    const url = window.location.origin + window.location.pathname + '?' + p.toString();
    navigator.clipboard.writeText(url).then(() => alert('Link copied!'));
  }, [lotW, lotD, zone, street, address, asking, lotSFOverride, hasRemainder, remDepth, driveW, driveX]);

  const takeScreenshot = useCallback(() => {
    const el = canvasRef.current;
    if (!el) return;
    html2canvas(el, { backgroundColor: '#f5f5f5', scale: 2 }).then(canvas => {
      const link = document.createElement('a');
      link.download = `lot-layout-${address || 'plan'}.png`;
      link.href = canvas.toDataURL();
      link.click();
    });
  }, [address]);

  /* ── Render helpers ─────────────────────────────────── */
  const fmt = (n) => n != null ? n.toLocaleString() : '\u2014';
  const fmtM = (n) => n != null ? '$' + (n >= 1e6 ? (n/1e6).toFixed(2) + 'M' : n.toLocaleString()) : '\u2014';
  const streetLabel = { N: 'top', S: 'bottom', E: 'right', W: 'left' }[street] || 'bottom';

  // Dev zone bounds (for display)
  const devZoneX = sideSB;
  const devZoneY = devStartY + frontSB;
  const devZoneW = lotW - 2 * sideSB;
  const devZoneH = Math.max(0, lotD - devStartY - frontSB - rearSB);

  // Driveway rect for overlap checks in render
  const driveRect = { x: driveX, y: driveY, w: driveW, h: driveH };

  // Is unit overlapping driveway or another unit?
  const unitHasOverlap = (u) => {
    if (rectsOverlap(u, driveRect)) return true;
    for (const other of units) {
      if (other.id === u.id) continue;
      if (rectsOverlap(u, other)) return true;
    }
    return false;
  };

  // Handle size for resize handles (in SVG/feet units)
  const HS = 3; // visible handle size
  const HIT = Math.max(6, Math.min(10, lotW * 0.05)); // hit area width

  /* ── Render resize handles for a unit ─────────────────── */
  const renderUnitHandles = (u) => {
    const edges = [
      { edge: 'right',  hx: u.x + u.w - HIT/2, hy: u.y, hw: HIT, hh: u.h,
        vx: u.x + u.w - HS/2, vy: u.y + u.h/2 - HS*1.5, vw: HS, vh: HS*3, cursor: 'ew-resize' },
      { edge: 'left',   hx: u.x - HIT/2, hy: u.y, hw: HIT, hh: u.h,
        vx: u.x - HS/2, vy: u.y + u.h/2 - HS*1.5, vw: HS, vh: HS*3, cursor: 'ew-resize' },
      { edge: 'bottom', hx: u.x, hy: u.y + u.h - HIT/2, hw: u.w, hh: HIT,
        vx: u.x + u.w/2 - HS*1.5, vy: u.y + u.h - HS/2, vw: HS*3, vh: HS, cursor: 'ns-resize' },
      { edge: 'top',    hx: u.x, hy: u.y - HIT/2, hw: u.w, hh: HIT,
        vx: u.x + u.w/2 - HS*1.5, vy: u.y - HS/2, vw: HS*3, vh: HS, cursor: 'ns-resize' },
    ];
    return edges.map(({ edge, hx, hy, hw, hh, vx, vy, vw, vh, cursor }) => (
      <g key={`handle-${u.id}-${edge}`}>
        {/* Invisible hit area */}
        <rect x={ox + hx} y={oy + hy} width={hw} height={hh}
          fill="transparent" style={{ cursor }}
          onPointerDown={e => startUnitResize(e, u.id, edge)} />
        {/* Visible indicator */}
        <rect x={ox + vx} y={oy + vy} width={vw} height={vh} rx={1}
          fill="white" stroke="#5B8BD8" strokeWidth={0.6}
          style={{ pointerEvents: 'none' }} />
      </g>
    ));
  };

  /* ── Render driveway resize handles ────────────────── */
  const renderDriveHandles = () => {
    if (driveH <= 0) return null;
    const edges = [
      { edge: 'left',  hx: driveX - HIT/2, vx: driveX - HS/2, cursor: 'ew-resize' },
      { edge: 'right', hx: driveX + driveW - HIT/2, vx: driveX + driveW - HS/2, cursor: 'ew-resize' },
    ];
    return edges.map(({ edge, hx, vx, cursor }) => (
      <g key={`drive-handle-${edge}`}>
        <rect x={ox + hx} y={oy + driveY} width={HIT} height={driveH}
          fill="transparent" style={{ cursor }}
          onPointerDown={e => startDriveResize(e, edge)} />
        <rect x={ox + vx} y={oy + driveY + driveH/2 - HS*2}
          width={HS} height={HS*4} rx={1}
          fill="white" stroke="#999" strokeWidth={0.5}
          style={{ pointerEvents: 'none' }} />
      </g>
    ));
  };

  return (
    <div style={{height:'100vh',display:'flex',flexDirection:'column'}}>
      {/* Title bar */}
      <div className="title-bar">
        <div style={{display:'flex',alignItems:'center',gap:16}}>
          <h1>SB 1123 Lot Layout Planner</h1>
          <span className="brand">by Yardsworth</span>
        </div>
        {address && <span className="address">{address}</span>}
        <div className="title-actions">
          <button className="title-btn" onClick={copyLink}>Copy Link</button>
          <button className="title-btn" onClick={takeScreenshot}>Screenshot</button>
        </div>
      </div>

      <div className="app-layout">
        {/* ── Sidebar ── */}
        <div className="sidebar">
          {/* Lot Input */}
          <div className="section">
            <div className="section-title">Lot Dimensions</div>
            {address && <div className="field"><label>Address</label><input value={address} onChange={e=>setAddress(e.target.value)} /></div>}
            <div className="field-row">
              <div className="field">
                <label>Width (ft)</label>
                <input type="number" value={lotW} min={20} max={500}
                  onChange={e=>setLotW(Math.max(1,Number(e.target.value)))} />
              </div>
              <div className="field">
                <label>Depth (ft)</label>
                <input type="number" value={lotD} min={20} max={1000}
                  onChange={e=>setLotD(Math.max(1,Number(e.target.value)))} />
              </div>
            </div>
            <div className="field">
              <label>Street Frontage</label>
              <div className="toggle-group">
                {['N','S','E','W'].map(d => (
                  <button key={d} className={`toggle-btn${street===d?' active':''}`}
                    onClick={()=>setStreet(d)}>{d}</button>
                ))}
              </div>
            </div>
            <div className="field">
              <label>Zone</label>
              <select value={zone} onChange={e=>setZone(e.target.value)}>
                {['RA','RE','R1','RD','R2','R3','R4','LAND'].map(z => (
                  <option key={z} value={z}>{z}</option>
                ))}
              </select>
            </div>
            <div className="checkbox-field">
              <input type="checkbox" id="rem" checked={hasRemainder}
                onChange={e=>{setHasRemainder(e.target.checked);if(!e.target.checked)setRemDepth(0);}} />
              <label htmlFor="rem">Existing structure (remainder parcel)</label>
            </div>
            {hasRemainder && (
              <div className="field">
                <label>Remainder depth (ft)</label>
                <input type="number" value={remDepth} min={0} max={lotD-40}
                  onChange={e=>setRemDepth(Math.max(0,Number(e.target.value)))} />
              </div>
            )}
          </div>

          {/* Development Standards */}
          <div className="section">
            <div className="section-title">Development Standards</div>
            <div className="field-row">
              <div className="field"><label>Front setback</label>
                <input type="number" value={frontSB} min={0} max={50}
                  onChange={e=>setFrontSB(Number(e.target.value))} /></div>
              <div className="field"><label>Rear setback</label>
                <input type="number" value={rearSB} min={0} max={50}
                  onChange={e=>setRearSB(Number(e.target.value))} /></div>
            </div>
            <div className="field">
              <label>Side setback</label>
              <input type="number" value={sideSB} min={0} max={30}
                onChange={e=>setSideSB(Number(e.target.value))} />
            </div>
            <div className="field-row">
              <div className="field"><label>Driveway width</label>
                <input type="number" value={driveW} min={12} max={28}
                  onChange={e=>{const v=Number(e.target.value);setDriveW(v);}} /></div>
              <div className="field">
                <label>Driveway snap</label>
                <div className="toggle-group">
                  <button className={`toggle-btn${driveX < lotW/2 ? ' active':''}`}
                    onClick={snapDriveLeft}>Left</button>
                  <button className={`toggle-btn${driveX >= lotW/2 ? ' active':''}`}
                    onClick={snapDriveRight}>Right</button>
                </div>
              </div>
            </div>
            <div className="field-row">
              <div className="field"><label>New unit width (ft)</label>
                <input type="number" value={defUnitW} min={12} max={26}
                  onChange={e=>setDefUnitW(Number(e.target.value))} /></div>
              <div className="field"><label>New unit depth (ft)</label>
                <input type="number" value={defUnitD} min={12} max={50}
                  onChange={e=>setDefUnitD(Number(e.target.value))} /></div>
            </div>
            <div className="field">
              <label>Stories</label>
              <div className="toggle-group">
                <button className={`toggle-btn${stories===2?' active':''}`}
                  onClick={()=>setStories(2)}>2</button>
                <button className={`toggle-btn${stories===3?' active':''}`}
                  onClick={()=>setStories(3)}>3</button>
              </div>
            </div>
            <div className="field-row" style={{marginTop:4}}>
              <div className="field"><label style={{color:'#999'}}>Min parcel</label>
                <div style={{fontSize:13,fontWeight:600,color:'#666',padding:'6px 0'}}>1,200 SF</div></div>
              <div className="field"><label style={{color:'#999'}}>Max units</label>
                <div style={{fontSize:13,fontWeight:600,color:'#666',padding:'6px 0'}}>10</div></div>
            </div>
          </div>

          {/* Layout controls */}
          <div className="section">
            <div className="section-title">Layout</div>
            <div className="checkbox-field">
              <input type="checkbox" id="dbl" checked={doubleLoaded}
                onChange={e=>setDoubleLoaded(e.target.checked)} />
              <label htmlFor="dbl">Double-loaded (central driveway)</label>
            </div>
            {lotW > 80 && !doubleLoaded && (
              <div style={{fontSize:11,color:'#E65100',marginBottom:8}}>
                Lot is {lotW}' wide — consider double-loaded layout
              </div>
            )}
            <div className="action-buttons">
              <button className="btn btn-primary" onClick={runAutoLayout}>Auto Layout</button>
              <button className="btn" onClick={addUnit} disabled={units.length>=10}>+ Add Unit</button>
              <button className="btn btn-danger" onClick={()=>setUnits([])}>Reset</button>
            </div>
          </div>

          {/* Pro forma */}
          <div className="section">
            <div className="section-title">Pro Forma</div>
            <div className="field">
              <label>Exit $/SF</label>
              <input type="number" value={ppsf} min={100} max={2000} step={25}
                onChange={e=>setPpsf(Number(e.target.value))} />
            </div>
            {asking && (
              <div className="field">
                <label>Asking price</label>
                <div style={{fontSize:14,fontWeight:700,color:'#1B2A4A'}}>{fmtM(asking)}</div>
              </div>
            )}
            <div className="field">
              <label>Revenue estimate</label>
              <div style={{fontSize:14,fontWeight:700,color:'#2E7D32'}}>{fmtM(revenue)}</div>
            </div>
          </div>

          {/* Warnings */}
          {warnings.length > 0 && (
            <div className="section" style={{background:'#FFF8E1'}}>
              <div className="section-title" style={{color:'#E65100'}}>Warnings</div>
              {warnings.map((w,i) => (
                <div key={i} style={{fontSize:11,color:'#BF360C',marginBottom:4}}>{w}</div>
              ))}
            </div>
          )}
        </div>

        {/* ── Main Canvas ── */}
        <div className="main-area">
          <div className="canvas-wrap" ref={canvasRef}>
            <svg ref={svgRef} className="lot-svg" viewBox={`0 0 ${vbW} ${vbH}`}
              preserveAspectRatio="xMidYMid meet"
              onPointerMove={handlePointerMove}
              onPointerUp={handlePointerUp}
              onPointerLeave={handlePointerUp}>

              {/* Grid background */}
              <defs>
                <pattern id="grid10" width={10} height={10} patternUnits="userSpaceOnUse" x={ox} y={oy}>
                  <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#e8e8e8" strokeWidth="0.3"/>
                </pattern>
                <pattern id="grid50" width={50} height={50} patternUnits="userSpaceOnUse" x={ox} y={oy}>
                  <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#ddd" strokeWidth="0.5"/>
                </pattern>
              </defs>
              <rect x={ox} y={oy} width={lotW} height={lotD} fill="url(#grid10)"/>
              <rect x={ox} y={oy} width={lotW} height={lotD} fill="url(#grid50)"/>

              {/* Lot boundary */}
              <rect x={ox} y={oy} width={lotW} height={lotD}
                fill="#F5F5F5" fillOpacity={0.5} stroke="#1B2A4A" strokeWidth={1.5} />

              {/* Remainder parcel */}
              {hasRemainder && remDepth > 0 && (
                <g>
                  <rect x={ox} y={oy} width={lotW} height={remDepth}
                    fill="#D7CCC8" fillOpacity={0.5} stroke="#A1887F" strokeWidth={0.8}
                    strokeDasharray="4,3" />
                  <text x={ox + lotW/2} y={oy + remDepth/2} textAnchor="middle"
                    dominantBaseline="middle" fontSize={Math.min(10, remDepth/3)}
                    fill="#6D4C41" fontWeight="600" className="dim-label">
                    Existing Home
                  </text>
                  <text x={ox + lotW + 6} y={oy + remDepth/2} textAnchor="start"
                    dominantBaseline="middle" fontSize={7} fill="#795548" className="dim-label">
                    {remDepth}'
                  </text>
                </g>
              )}

              {/* Development zone fill */}
              {devZoneW > 0 && devZoneH > 0 && (
                <rect x={ox + devZoneX} y={oy + devZoneY}
                  width={devZoneW} height={devZoneH}
                  fill="white" fillOpacity={0.4} stroke="none" />
              )}

              {/* Setback lines */}
              <line x1={ox} y1={oy + devStartY + frontSB}
                x2={ox + lotW} y2={oy + devStartY + frontSB}
                stroke="#FF5722" strokeWidth={0.6} strokeDasharray="3,2" />
              <text x={ox - 3} y={oy + devStartY + frontSB} textAnchor="end"
                dominantBaseline="middle" fontSize={6} fill="#FF5722" className="dim-label">
                {frontSB}' front
              </text>

              <line x1={ox} y1={oy + lotD - rearSB}
                x2={ox + lotW} y2={oy + lotD - rearSB}
                stroke="#FF5722" strokeWidth={0.6} strokeDasharray="3,2" />
              <text x={ox - 3} y={oy + lotD - rearSB} textAnchor="end"
                dominantBaseline="middle" fontSize={6} fill="#FF5722" className="dim-label">
                {rearSB}' rear
              </text>

              <line x1={ox + sideSB} y1={oy + devStartY}
                x2={ox + sideSB} y2={oy + lotD}
                stroke="#FF5722" strokeWidth={0.6} strokeDasharray="3,2" />
              <line x1={ox + lotW - sideSB} y1={oy + devStartY}
                x2={ox + lotW - sideSB} y2={oy + lotD}
                stroke="#FF5722" strokeWidth={0.6} strokeDasharray="3,2" />

              {/* Driveway — draggable + resizable */}
              {driveH > 0 && (
                <g onPointerEnter={() => !dragInfo && setHoveredDrive(true)}
                   onPointerLeave={() => !dragInfo && setHoveredDrive(false)}>
                  {/* Driveway body */}
                  <rect x={ox + driveX} y={oy + driveY}
                    width={driveW} height={driveH}
                    fill="#D5D0CB" fillOpacity={0.7}
                    stroke={hoveredDrive || (dragInfo && dragInfo.type.startsWith('drive')) ? '#888' : '#B0A89F'}
                    strokeWidth={hoveredDrive || (dragInfo && dragInfo.type.startsWith('drive')) ? 1 : 0.5}
                    style={{ cursor: dragInfo && dragInfo.type === 'drive-move' ? 'grabbing' : 'grab' }}
                    onPointerDown={startDriveMove} />
                  {/* Driveway label */}
                  <text x={ox + driveX + driveW/2} y={oy + driveY + driveH/2}
                    textAnchor="middle" dominantBaseline="middle"
                    fontSize={Math.min(7, driveW/4)} fill="#6B6B6B" fontWeight="600"
                    className="dim-label"
                    transform={`rotate(-90, ${ox+driveX+driveW/2}, ${oy+driveY+driveH/2})`}>
                    Driveway {driveW}'
                  </text>
                  {/* Resize handles (always shown when hovered or dragging) */}
                  {(hoveredDrive || (dragInfo && dragInfo.type.startsWith('drive'))) && renderDriveHandles()}
                </g>
              )}

              {/* Yard space behind units */}
              {units.map(u => {
                // Compute yard on the far side from driveway
                const driveCenterX = driveX + driveW / 2;
                const unitCenterX = u.x + u.w / 2;
                const driveIsLeft = driveCenterX < unitCenterX;
                let yardX, yardW;
                if (driveIsLeft) {
                  // Yard on right side of unit
                  yardX = u.x + u.w;
                  yardW = lotW - u.x - u.w;
                } else {
                  // Yard on left side of unit
                  yardX = 0;
                  yardW = u.x;
                }
                if (yardW <= 0) return null;
                return (
                  <rect key={`yard-${u.id}`}
                    x={ox + yardX} y={oy + u.y}
                    width={yardW} height={u.h}
                    fill="#C8E6C9" fillOpacity={0.3} stroke="none" />
                );
              })}

              {/* Units — draggable + resizable */}
              {units.map(u => {
                const isHovered = hoveredUnit === u.id;
                const isDragging = dragInfo && dragInfo.unitId === u.id;
                const isMoving = isDragging && dragInfo.type === 'unit-move';
                const invalid = u.x < sideSB - 0.5 || u.x + u.w > lotW - sideSB + 0.5
                  || u.y < devStartY + frontSB - 0.5 || u.y + u.h > lotD - rearSB + 0.5
                  || unitHasOverlap(u);

                return (
                  <g key={u.id}
                    onPointerEnter={() => !dragInfo && setHoveredUnit(u.id)}
                    onPointerLeave={() => !dragInfo && setHoveredUnit(null)}>
                    {/* Unit rectangle */}
                    <rect
                      x={ox + u.x} y={oy + u.y} width={u.w} height={u.h}
                      fill={invalid ? '#FFCDD2' : '#3B7DD8'}
                      fillOpacity={isHovered ? 0.9 : 0.75}
                      stroke={invalid ? '#D32F2F' : '#2C3E6B'}
                      strokeWidth={isHovered || isDragging ? 2 : 1}
                      rx={1}
                      style={{ cursor: isMoving ? 'grabbing' : 'grab' }}
                      onPointerDown={e => startUnitMove(e, u.id)}
                    />
                    {/* Garage outline (fixed 12' x min(42',depth), driveway side) */}
                    {(() => {
                      const g = garageForUnit(u);
                      const driveCX = driveX + driveW / 2;
                      const unitCX = u.x + u.w / 2;
                      const driveIsLeft = driveCX < unitCX;
                      const gx = driveIsLeft ? u.x : u.x + u.w - g.gd;
                      const gy = u.y;
                      return (
                        <g style={{ pointerEvents: 'none' }}>
                          <rect x={ox + gx + 0.5} y={oy + gy + 0.5}
                            width={g.gd - 1} height={g.gw - 1}
                            fill="rgba(0,0,0,0.15)" stroke="rgba(255,255,255,0.5)"
                            strokeWidth={0.5} strokeDasharray="2,1.5" rx={0.5} />
                          <text x={ox + gx + g.gd/2} y={oy + gy + g.gw/2}
                            textAnchor="middle" dominantBaseline="middle"
                            fontSize={Math.min(4, g.gd/10, g.gw/4)} fill="rgba(255,255,255,0.7)"
                            className="dim-label">
                            Garage
                          </text>
                        </g>
                      );
                    })()}
                    {/* Unit label */}
                    <text x={ox + u.x + u.w/2} y={oy + u.y + u.h/2 - 2}
                      textAnchor="middle" dominantBaseline="middle"
                      fontSize={Math.min(7, Math.min(u.w, u.h)/4)} fill="white" fontWeight="700"
                      className="dim-label">
                      Unit {u.id}
                    </text>
                    <text x={ox + u.x + u.w/2} y={oy + u.y + u.h/2 + 5}
                      textAnchor="middle" dominantBaseline="middle"
                      fontSize={Math.min(5, Math.min(u.w, u.h)/6)} fill="rgba(255,255,255,0.85)"
                      className="dim-label">
                      {u.w}' x {u.h}'
                    </text>

                    {/* Resize handles (shown on hover or during resize of this unit) */}
                    {(isHovered || isDragging) && !isMoving && renderUnitHandles(u)}

                    {/* Delete button on hover (not during drag) */}
                    {isHovered && !isDragging && (
                      <g style={{cursor:'pointer'}} onClick={() => removeUnit(u.id)}>
                        <circle cx={ox + u.x + u.w - 3} cy={oy + u.y + 3} r={4}
                          fill="#D32F2F" />
                        <text x={ox + u.x + u.w - 3} y={oy + u.y + 3.5}
                          textAnchor="middle" dominantBaseline="middle"
                          fontSize={5} fill="white" fontWeight="700"
                          className="dim-label">x</text>
                      </g>
                    )}
                  </g>
                );
              })}

              {/* Street label */}
              {streetLabel === 'bottom' && (
                <g>
                  <rect x={ox} y={oy + lotD + 2} width={lotW} height={12} fill="#6B6B6B" rx={1} />
                  <text x={ox + lotW/2} y={oy + lotD + 9} textAnchor="middle"
                    fontSize={6} fill="white" fontWeight="600" className="dim-label">STREET</text>
                </g>
              )}
              {streetLabel === 'top' && (
                <g>
                  <rect x={ox} y={oy - 14} width={lotW} height={12} fill="#6B6B6B" rx={1} />
                  <text x={ox + lotW/2} y={oy - 7} textAnchor="middle"
                    fontSize={6} fill="white" fontWeight="600" className="dim-label">STREET</text>
                </g>
              )}
              {streetLabel === 'left' && (
                <g>
                  <rect x={ox - 14} y={oy} width={12} height={lotD} fill="#6B6B6B" rx={1} />
                  <text x={ox - 8} y={oy + lotD/2} textAnchor="middle"
                    fontSize={6} fill="white" fontWeight="600" className="dim-label"
                    transform={`rotate(-90, ${ox-8}, ${oy+lotD/2})`}>STREET</text>
                </g>
              )}
              {streetLabel === 'right' && (
                <g>
                  <rect x={ox + lotW + 2} y={oy} width={12} height={lotD} fill="#6B6B6B" rx={1} />
                  <text x={ox + lotW + 8} y={oy + lotD/2} textAnchor="middle"
                    fontSize={6} fill="white" fontWeight="600" className="dim-label"
                    transform={`rotate(90, ${ox+lotW+8}, ${oy+lotD/2})`}>STREET</text>
                </g>
              )}

              {/* Dimension labels */}
              <g>
                <line x1={ox} y1={oy - 18} x2={ox + lotW} y2={oy - 18}
                  stroke="#1B2A4A" strokeWidth={0.5} />
                <line x1={ox} y1={oy - 20} x2={ox} y2={oy - 16} stroke="#1B2A4A" strokeWidth={0.5} />
                <line x1={ox+lotW} y1={oy - 20} x2={ox+lotW} y2={oy - 16} stroke="#1B2A4A" strokeWidth={0.5} />
                <text x={ox + lotW/2} y={oy - 20} textAnchor="middle" fontSize={7}
                  fill="#1B2A4A" fontWeight="600" className="dim-label">{lotW}'</text>
              </g>
              <g>
                <line x1={ox + lotW + 18} y1={oy} x2={ox + lotW + 18} y2={oy + lotD}
                  stroke="#1B2A4A" strokeWidth={0.5} />
                <line x1={ox + lotW + 16} y1={oy} x2={ox + lotW + 20} y2={oy} stroke="#1B2A4A" strokeWidth={0.5} />
                <line x1={ox + lotW + 16} y1={oy+lotD} x2={ox + lotW + 20} y2={oy+lotD} stroke="#1B2A4A" strokeWidth={0.5} />
                <text x={ox + lotW + 22} y={oy + lotD/2} textAnchor="start"
                  dominantBaseline="middle" fontSize={7}
                  fill="#1B2A4A" fontWeight="600" className="dim-label">{lotD}'</text>
              </g>

              {/* Scale bar */}
              <g>
                {(() => {
                  const scaleLen = lotW > 200 ? 50 : lotW > 100 ? 20 : 10;
                  const bx = ox + 4, by = oy + lotD + (streetLabel === 'bottom' ? 20 : 6);
                  return (
                    <>
                      <rect x={bx} y={by} width={scaleLen} height={2} fill="#1B2A4A" />
                      <line x1={bx} y1={by-1} x2={bx} y2={by+3} stroke="#1B2A4A" strokeWidth={0.5} />
                      <line x1={bx+scaleLen} y1={by-1} x2={bx+scaleLen} y2={by+3} stroke="#1B2A4A" strokeWidth={0.5} />
                      <text x={bx + scaleLen/2} y={by+7} textAnchor="middle" fontSize={5}
                        fill="#666" className="dim-label">{scaleLen} ft</text>
                    </>
                  );
                })()}
              </g>

              {/* North arrow */}
              <g transform={`translate(${ox + lotW + 18}, ${oy + lotD - 10})`}>
                <line x1={0} y1={10} x2={0} y2={0} stroke="#1B2A4A" strokeWidth={1} />
                <polygon points="-3,4 0,0 3,4" fill="#1B2A4A" />
                <text x={0} y={-3} textAnchor="middle" fontSize={6} fill="#1B2A4A"
                  fontWeight="700" className="dim-label">N</text>
              </g>

              {/* Hover tooltip */}
              {hoveredUnit && !dragInfo && (() => {
                const u = units.find(u => u.id === hoveredUnit);
                if (!u) return null;
                const tx = ox + u.x + u.w + 5;
                const ty = oy + u.y;
                return (
                  {(() => {
                    const g = garageForUnit(u);
                    const habSF = u.w * u.h * stories - g.sf;
                    return (
                      <g className="tooltip-box">
                        <rect x={tx} y={ty} width={64} height={46} fill="white"
                          stroke="#ccc" strokeWidth={0.5} rx={2} />
                        <text x={tx+4} y={ty+9} fontSize={5} fill="#333" className="dim-label">
                          Unit {u.id}: {u.w}' x {u.h}'
                        </text>
                        <text x={tx+4} y={ty+17} fontSize={5} fill="#666" className="dim-label">
                          Garage: {g.gd}' x {g.gw}' = {fmt(g.sf)} SF
                        </text>
                        <text x={tx+4} y={ty+25} fontSize={5} fill="#666" className="dim-label">
                          Habitable: {fmt(habSF)} SF
                        </text>
                        <text x={tx+4} y={ty+33} fontSize={5} fill="#999" className="dim-label">
                          Total: {fmt(u.w * u.h * stories)} SF ({stories}F)
                        </text>
                        <text x={tx+4} y={ty+41} fontSize={4.5} fill="#aaa" className="dim-label">
                          Drag edges to resize
                        </text>
                      </g>
                    );
                  })()}
                );
              })()}
            </svg>
          </div>

          {/* ── Stats bar ── */}
          <div className="stats-bar">
            <div className="stats-grid">
              <div className="stat">
                <span className="stat-label">Lot</span>
                <span className="stat-value">{fmt(totalLotSF)} SF</span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">Dev Area</span>
                <span className="stat-value">{fmt(devLotSF)} SF</span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">Units</span>
                <span className={`stat-value${units.length>10?' warn':''}`}>
                  {units.length} / 10
                </span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">Avg Parcel</span>
                <span className={`stat-value${avgParcel>0&&avgParcel<1200?' warn':''}`}>
                  {units.length > 0 ? fmt(Math.round(avgParcel)) + ' SF' : '\u2014'}
                </span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">Coverage</span>
                <span className="stat-value">{coverage.toFixed(1)}%</span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">Habitable</span>
                <span className="stat-value">{fmt(habitableSF)} SF</span>
              </div>
              <div className="stat-sep" />
              <div className="stat">
                <span className="stat-label">FAR</span>
                <span className="stat-value">{far.toFixed(2)}</span>
              </div>
              <div className="stat-sep" />
              <div className={`compliance-badge ${warnings.length === 0 ? 'pass' : 'fail'}`}>
                {warnings.length === 0 ? '\u2713 Compliant' : `\u2717 ${warnings.length} issue${warnings.length>1?'s':''}`}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>